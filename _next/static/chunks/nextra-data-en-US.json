{"/build":{"title":"Build a React Native library","data":{"":"When code is in non-standard syntaxes such as JSX, TypeScript etc, it needs to be compiled before it can run. Configuring this manually can be error-prone and annoying. react-native-builder-bob aims to simplify this process by wrapping babel and tsc and taking care of the configuration. See this section for a longer explanation.Supported targets are:\nGeneric CommonJS build\nES modules build for bundlers such as webpack\nTypeScript definitions\nFlow definitions (copies .js files to .flow files)\nIf you created a project with create-react-native-library, react-native-builder-bob is already pre-configured to build your project. You don't need to configure it again.The following configuration steps are for projects not created with create-react-native-library.","automatic-configuration#Automatic configuration":"To automatically configure your project to use react-native-builder-bob, open a Terminal and run:\nnpx react-native-builder-bob@latest init\nThis will ask you a few questions and add the required configuration and scripts for building the code. The code will be compiled automatically when the package is published.You can find details on what exactly it adds in the Manual configuration section.","manual-configuration#Manual configuration":"To configure your project manually, follow these steps:\nFirst, install react-native-builder-bob in your project. Open a Terminal in your project, and run:\nyarn add --dev react-native-builder-bob\nIn your package.json, specify the targets to build for:\n\"react-native-builder-bob\": {\n  \"source\": \"src\",\n  \"output\": \"lib\",\n  \"targets\": [\n    \"commonjs\",\n    \"module\",\n    \"typescript\",\n  ]\n}\nSee the Options section for more details.\nAdd bob to your prepare or prepack step:\n\"scripts\": {\n  \"prepare\": \"bob build\"\n}\nNote that there is a difference between prepare and prepack scripts:\nprepare is run when:\nThe package is published with Yarn 1 (yarn publish), npm (npm publish) or pnpm (pnpm publish)\nThe package is installed from a GIT URL with Yarn 1 (yarn add <git-url>), npm (npm install <git-url>) or pnpm (pnpm add <git-url>)\nprepack is run when:\nThe package is published with any package manager (yarn publish, npm publish, pnpm publish)\nThe package is installed from a GIT URL with Yarn 4 (yarn add package-name@<git-url>)\nIf you are not sure which one to use, we recommend going with prepare as it works during both publishing and installing from GIT with more package managers.\nConfigure the appropriate entry points:\n\"main\": \"lib/commonjs/index.js\",\n\"module\": \"lib/module/index.js\",\n\"react-native\": \"src/index.ts\",\n\"types\": \"lib/typescript/src/index.d.ts\",\n\"source\": \"src/index.ts\",\n\"files\": [\n  \"lib\",\n  \"src\"\n]\nHere is what each of these fields mean:\nmain: The entry point for the commonjs build. This is used by Node - such as tests, SSR etc.\nmodule: The entry point for the ES module build. This is used by bundlers such as webpack.\nreact-native: The entry point for the React Native apps. This is used by Metro. It's common to point to the source code here as it can make debugging easier.\ntypes: The entry point for the TypeScript definitions. This is used by TypeScript to type check the code using your library.\nsource: The path to the source code. It is used by react-native-builder-bob to detect the correct output files and provide better error messages.\nfiles: The files to include in the package when publishing with npm.\nMake sure to change specify correct files according to the targets you have enabled.NOTE: If you're building TypeScript definition files, also make sure that the types field points to a correct path. Depending on the project configuration, the path can be different for you than the example snippet (e.g. lib/typescript/index.d.ts if you have only the src directory and rootDir is not set).\nAdd the output directory to .gitignore and .eslintignore\n# generated files by bob\nlib/\nThis makes sure that you don't accidentally commit the generated files to git or get lint errors for them.\nAdd the output directory to jest.modulePathIgnorePatterns if you use Jest\n\"modulePathIgnorePatterns\": [\"<rootDir>/lib/\"]\nThis makes sure that Jest doesn't try to run the tests in the generated files.\nAnd we're done ðŸŽ‰","options#Options":"The options can be specified in the package.json file under the react-native-builder-bob property, or in a bob.config.js file in your project directory.","source#source":"The name of the folder with the source code which should be compiled. The folder should include an index file.","output#output":"The name of the folder where the compiled files should be output to. It will contain separate folder for each target.","exclude#exclude":"Glob pattern to be used while filtering the unnecessary files. Defaults to '**/{__tests__,__fixtures__,__mocks__}/**' if not specified.Example:\n{\n  \"exclude\": \"ignore_me/**\"\n}\nThis option only works with commonjs and module targets. To exclude files while building typescript, please see the tsconfig exclude field.","targets#targets":"Various targets to build for. The available targets are:","commonjs#commonjs":"Enable compiling source files with Babel and use commonjs module system.This is useful for running the code in Node (SSR, tests etc.). The output file should be referenced in the main field of package.json.By default, the code is compiled to support last 2 versions of modern browsers. It also strips TypeScript and Flow annotations, and compiles JSX. You can customize the environments to compile for by using a browserslist config.In addition, the following options are supported:\nconfigFile & babelrc (boolean): To customize the babel config used, you can pass the configFile option as true if you have a babel.config.js or babelrc option if you have a .babelrc. This may break the default configuration, so use these options only if you know what you're doing.\ncopyFlow (boolean): If your source code is written in Flow, You can specify the copyFlow option to copy the source files as .js.flow to the output folder. If the main entry in package.json points to the index file in the output folder, the flow type checker will pick these files up to use for type definitions.\nsourceMaps (boolean): Sourcemaps are generated by default alongside the compiled files. You can disable them by setting the sourceMaps option to false.\nExample:\n[\"commonjs\", { \"configFile\": true, \"copyFlow\": true }]","module#module":"Enable compiling source files with Babel and use ES module system. This is essentially same as the commonjs target and accepts the same options, but leaves the import/export statements in your code.This is useful for bundlers which understand ES modules and can tree-shake. The output file should be referenced in the module field of package.json.Example:\n[\"module\", { \"configFile\": true }]","typescript#typescript":"Enable generating type definitions with tsc if your source code is written in TypeScript.The following options are supported:\nproject (string): By default, the tsconfig.json file in the root of your project is used to generate the type definitions. You can specify a path to a different config by using the project option. This can be useful if you need to use different configs for development and production.\ntsc (string): The path to the tsc binary is automatically detected and defaults to the one installed in your project. You can use the tsc option to specify a different path.\nExample:\n[\"typescript\", { \"project\": \"tsconfig.build.json\" }]","commands#Commands":"The bob CLI exposes the following commands:","init#init":"This configures an existing project to use bob by adding the required configuration and dependencies. This is usually run with npx:\nnpx react-native-builder-bob@latest init","build#build":"This builds the project according to the configuration. This is usually run as part of the package's publishing flow, i.e. in the prepare or prepack scripts.\n\"scripts\": {\n  \"prepare\": \"bob build\"\n}"}},"/create":{"title":"Scaffold a React Native library","data":{"":"If you want to create your own React Native library, scaffolding the project can be a daunting task. create-react-native-library can scaffold a new project for you with all the necessary tools configured.","features#Features":"Minimal boilerplate for libraries on which you can build upon\nExample React Native app to test your library code\nTypeScript to ensure type-safe code and better DX\nSupport for Turbo Modules & Fabric\nSupport for Kotlin on Android & Swift on iOS\nSupport for C++ to write cross-platform native code\nExpo for libraries without native code and web support\nESLint, Prettier, TypeScript, Lefthook and Release It pre-configured\nreact-native-builder-bob pre-configured to compile your files\nGitHub Actions pre-configured to run tests and lint on the CI","usage#Usage":"To create new project, run the following:\nnpx create-react-native-library@latest awesome-library\nThis will ask you a few questions about your project and generate a new project in a folder named awesome-library.After the project is created, you can find the development workflow in the generated CONTRIBUTING.md file.","local-library#Local library":"While the default templates are for libraries that are published to npm, you can also create a local library that is not published but used locally in your app.You'd typically use a local library when:\nYou're building a native library for your app and don't want to publish it to npm.\nYou want to be able to easily copy the library to other projects.\nYou're in a monorepo and want to keep the library code in the same repository as the app.\nYou're using Expo, but want to use vanilla React Native API for native modules and components.\nThe structure of the app with a local library may look like this:\nMyApp\nâ”œâ”€â”€ node_modules\nâ”œâ”€â”€ modules              <-- folder for your local libraries\nâ”‚   â””â”€â”€ awesome-library  <-- your local library\nâ”œâ”€â”€ android\nâ”œâ”€â”€ ios\nâ”œâ”€â”€ src\nâ”œâ”€â”€ index.js\nâ””â”€â”€ package.json\nIf you run create-react-native-library in an existing project containing a package.json, it'll be automatically detected and you'll be asked if you want to create a local library. You can also pass the --local flag to the command to explicitly create a local library:\nnpx create-react-native-library@latest awesome-library --local\nThe local library is created outside of the android and ios folders and makes use of autolinking to integrate with your app. It also doesn't include a separate example app and additional dependencies that are configured in the default templates. This is an alternative approach to the setup mentioned in React Native docs.The advantages of this approach are:\nIt's easier to upgrade React Native as you don't need to worry about custom code in android and ios folders.\nIt can be used with Expo managed projects with custom development client.\nIt's easier to copy the library to other projects or publish later if needed.\nThe boilerplate for the library doesn't need to be written from scratch.\nIt can be used with monorepos where the additional tooling in the default templates may not be needed.\nBy default, the generated library is automatically linked to the project using link: protocol when using Yarn and file: when using npm:\n\"dependencies\": {\n  \"react-native-awesome-library\": \"link:./modules/awesome-library\"\n}\nThis creates a symlink to the library under node_modules which makes autolinking work. But if you're using a monorepo or have non-standard setup, you'll need to manually set up the package to be linked to your app based on your project setup.","writing-native-code#Writing native code":"Once the project is created, you can follow the official React Native docs to learn the API for writing native modules and components:\nNative Modules\nNative UI Components for Android\nNative UI Components for iOS\nTurbo Modules\nFabric Components"}},"/faq":{"title":"Frequently Asked Questions","data":{"why-should-i-compile-my-project-with-react-native-builder-bob#Why should I compile my project with react-native-builder-bob?":"We often write our library code in non-standard syntaxes such as JSX, TypeScript etc. as well as proposed syntaxes which aren't part of the standard yet. This means that our code needs to be compiled to be able to run on JavaScript engines.When using the library in a React Native app, Metro handles compiling the source code. However, it's also possible to use them in other targets such as:\nBrowsers or bundlers such as webpack (if we support Web)\nNode.js for tests or SSR etc.\nSo the code needs to be precompiled so these tools can parse it. In addition, we need to generate type definition files for TypeScript etc.To handle such multiple targets, one solution could is to have multiple babel configs (or TypeScript configs) and have a babel-cli command in our package.json for compilation. Ideally, we should also keep the configs in sync between our several projects.As an example, this is a command that we had in one of the packages:\nbabel --extensions '.js,.ts,.tsx' --no-babelrc --config-file=./babel.config.publish.js src --ignore '**/__tests__/**' --copy-files --source-maps --delete-dir-on-start --out-dir dist && del-cli 'dist/**/__tests__' && yarn tsc --emitDeclarationOnly\nAs you can see, it's quite long and hard to read. There's even a separate babel.config.publish.js file. And this only works for webpack and Metro, and will fail on Node due to ESM usage.react-native-builder-bob wraps tools such as babel and typescript to simplify these common tasks across multiple projects. While it can be used for any library, it's primarily tailored to React Native projects to minimize the configuration required.","how-do-i-add-a-react-native-library-containing-native-code-as-a-dependency-in-my-library#How do I add a react-native library containing native code as a dependency in my library?":"If your library depends on another react-native library containing native code, you should do the following:\nAdd the native library to peerDependenciesThis means that the consumer of the library will need to install the native library and add it to the dependencies section of their package.json. It makes sure that:\nThere are no version conflicts if another package also happens to use the same library, or if the user wants to use the library in their app. While there can be multiple versions of a JavaScript-only library, there can only be one version of a native library - so avoiding version conflicts is important.\nThe package manager installs it in correct location so that autolinking can work properly.\nDon't add the native library to dependencies of your library, otherwise it may cause issues for the user even if it seems to work.\nAdd the native library to devDependenciesThis makes sure that you can use it for tests, and there are no other errors such as type errors due to the missing module.\nAdd the native library to dependencies in the package.json under exampleThis is equivalent to the consumer of the library installing the dependency, and is needed so that this module is also available to the example app.","how-to-upgrade-the-react-native-version-in-the-generated-project#How to upgrade the react-native version in the generated project?":"Since this is a library, the react-native version specified in the package.json is not relevant for the consumers. It's only used for developing and testing the library. If you'd like to upgrade the react-native version to test with it, you'd need to:\nBump versions of the following packages under devDependencies in the package.json:\nreact-native\nreact\n@types/react\n@types/react-native\nIf you have any other related packages such as react-test-renderer, make sure to bump them as well.\nUpgrade react-native in the example appThe example app is a React Native app that can be updated following the same process as a regular React Native app. The process will vary depending on if it's using Expo or React Native CLI. See the official upgrade guide for more details.\nTo avoid issues, make sure that the versions of react and react-native are the same in example/package.json and the package.json at the root.","how-does-the-library-get-linked-to-the-example-app-in-the-generated-project#How does the library get linked to the example app in the generated project?":"If you generate a project with create-react-native-library, you get an example app to test your library. It's good to understand how the library gets linked to the example app in case you want to tweak how it works or if you run into issues.There are 2 parts to this process.\nAliasing the JavaScript codeThe JavaScript (or TypeScript) source code is aliased to be used by the example app. This makes it so that when you import from 'your-library-name', it imports the source code directly and avoids having to rebuild the library for JavaScript only changes. We configure several tools to make this work:\nBabel is configured to use the alias in example/babel.config.js using babel-plugin-module-resolver. This transforms the imports to point to the source code instead.\nMetro is configured to allow importing from outside of the example directory by configuring watchFolders, and to use the appropriate peer dependencies. This configuration exists in the example/metro.config.js file.\nWebpack is configured to compile the library source code when running on the Web. This configuration exists in the example/webpack.config.js file.\nTypeScript is configured to use the source code for type checking by using the paths property under compilerOptions. This configuration exists in the tsconfig.json file at the root.\nLinking the native codeBy default, React Native CLI only links the modules installed under node_module of the app. To be able to link the android and ios folders from the project root, the path is specified in the example/react-native.config.js file.","how-to-test-the-library-in-an-app-locally#How to test the library in an app locally?":"You may have come across the yarn link and npm link commands, or used npm install ../path/to/folder or yarn add ../path/to/folder to test libraries locally. These commands may work for simple packages without build process, but they have different behavior from how a published package works, e.g. .npmignore is not respected, the structure of node_modules is different, etc. So we don't recommended using these approaches to test libraries locally.For more accurate testing, there are various other approaches:\nLocal tarball with npmFirst, temporarily change the version in package.json to something like 0.0.0-local.0. This version number needs to be updated to something different every time you do this to avoid stale content.Run the following command inside your library's root:\nnpm pack\nThis will generate a file like your-library-name-0.0.0-local.0.tgz in the root of the project.Then, you can install the tarball in your app:\nyarn add ../path/to/your-library-name-0.0.0-local.0.tgz\nOr if you use npm:\nnpm install ../path/to/your-library-name-0.0.0-local.0.tgz\nYalcYalc acts as a local repository for packages that can be used to test packages locally. It's similar to the previous workflow, but more convenient to use.You can find installation and usage instructions in the Yalc documentation.\nVerdaccioVerdaccio is a lightweight private npm registry that can be used to test packages locally. The advantage of using Verdaccio is that it allows to test the complete workflow of publishing and installing a package without actually publishing it to a remote registry.You can find installation and usage instructions in the Verdaccio documentation.","users-get-a-warning-when-they-install-my-library#Users get a warning when they install my library":"If users are using Yarn 1, they may get a warning when installing your library:\nwarning Workspaces can only be enabled in private projects.\nThis is because the example app is configured as a Yarn workspace, and there is a bug in Yarn 1 which causes this warning to be shown for third-party packages. It has no impact for the consumers of the library and the warning can be ignored. If consumers would like to get rid of the warning, there are 2 options:\nDisable workspacesIf the consumer doesn't use Yarn workspaces, they can disable it by adding the following to the .yarnrc file in the root of their project:\nworkspaces-experimental false\nUpgrade to Yarn 3Yarn 1 is no longer maintained, so it's recommended to upgrade to Yarn 3. Yarn 3 works with React Native projects with the node-modules linker. To upgrade, consumers can follow the official upgrade guide.It's also necessary to use node-modules linker. To use it, consumers can add the following to the .yarnrc.yml file in the root of their project:\nnodeLinker: node-modules"}},"/":{"title":"Introduction","data":{"":"This project is a collection of tools to make it easier to build React Native libraries. It contains the following CLIs:\ncreate-react-native-library - a CLI to scaffold a React Native library.\nreact-native-builder-bob - a CLI to build React Native libraries for various targets."}}}