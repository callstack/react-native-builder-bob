{"/create":{"title":"Scaffold a React Native library","data":{"":"If you want to create your own React Native library, scaffolding the project can be a daunting task. create-react-native-library can scaffold a new project for you with all the necessary tools configured.","features#Features":"Minimal boilerplate for libraries on which you can build upon\nExample React Native app to test your library code\nTypeScript to ensure type-safe code and better DX\nSupport for Turbo Modules & Fabric\nSupport for Kotlin on Android & Swift on iOS\nSupport for C++ to write cross-platform native code\nExpo for libraries without native code and web support\nESLint, Prettier, TypeScript, Lefthook and Release It pre-configured\nreact-native-builder-bob pre-configured to compile your files\nGitHub Actions pre-configured to run tests and lint on the CI","usage#Usage":"To create new project, run the following:\nnpx create-react-native-library@latest awesome-library\nThis will ask you a few questions about your project and generate a new project in a folder named awesome-library.After the project is created, you can find the development workflow in the generated CONTRIBUTING.md file.\nNote: If you want to create a library using the legacy native modules and view APIs instead of the new architecture, you can use the 0.49.8 version of create-react-native-library: npx create-react-native-library@0.49.8 awesome-library.","local-library#Local library":"While the default templates are for libraries that are published to npm, you can also create a local library that is not published but used locally in your app.You'd typically use a local library when:\nYou're building a native library for your app and don't want to publish it to npm.\nYou want to be able to easily copy the library to other projects.\nYou're in a monorepo and want to keep the library code in the same repository as the app.\nYou're using Expo, but want to use vanilla React Native API for native modules and components.\nThe structure of the app with a local library may look like this:\nMyApp\n├── node_modules\n├── modules              <-- folder for your local libraries\n│   └── awesome-library  <-- your local library\n├── android\n├── ios\n├── src\n├── index.js\n└── package.json\nIf you run create-react-native-library in an existing project containing a package.json, it'll be automatically detected and you'll be asked if you want to create a local library. You can also pass the --local flag to the command to explicitly create a local library:\nnpx create-react-native-library@latest awesome-library --local\nThe local library is created outside of the android and ios folders and makes use of autolinking to integrate with your app. It also doesn't include a separate example app and additional dependencies that are configured in the default templates. This is an alternative approach to the setup mentioned in React Native docs.The advantages of this approach are:\nIt's easier to upgrade React Native as you don't need to worry about custom code in android and ios folders.\nIt can be used with Expo managed projects with custom development client.\nIt's easier to copy the library to other projects or publish later if needed.\nThe boilerplate for the library doesn't need to be written from scratch.\nIt can be used with monorepos where the additional tooling in the default templates may not be needed.\nBy default, the generated library is automatically linked to the project using link: protocol when using Yarn and file: when using npm:\n\"dependencies\": {\n  \"react-native-awesome-library\": \"link:./modules/awesome-library\"\n}\nThis creates a symlink to the library under node_modules which makes autolinking work. But if you're using a monorepo or have non-standard setup, you'll need to manually set up the package to be linked to your app based on your project setup.","writing-native-code#Writing native code":"Once the project is created, you can follow the official React Native docs to learn the API for writing native modules and components:\nNative Modules\nNative UI Components for Android\nNative UI Components for iOS\nTurbo Modules\nFabric Components"}},"/faq":{"title":"Frequently Asked Questions","data":{"why-should-i-compile-my-project-with-react-native-builder-bob#Why should I compile my project with react-native-builder-bob?":"We often write our library code in non-standard syntaxes such as JSX, TypeScript etc. as well as proposed syntaxes which aren't part of the standard yet. This means that our code needs to be compiled to be able to run on JavaScript engines.When using the library in a React Native app, Metro handles compiling the source code. However, it's also possible to use them in other targets such as:\nBrowsers or bundlers such as webpack (if we support Web)\nNode.js for tests or SSR etc.\nSo the code needs to be precompiled so these tools can parse it. In addition, we need to generate type definition files for TypeScript etc.To handle such multiple targets, one solution could is to have multiple babel configs (or TypeScript configs) and have a babel-cli command in our package.json for compilation. Ideally, we should also keep the configs in sync between our several projects.As an example, this is a command that we had in one of the packages:\nbabel --extensions '.js,.ts,.tsx' --no-babelrc --config-file=./babel.config.publish.js src --ignore '**/__tests__/**' --copy-files --source-maps --delete-dir-on-start --out-dir dist && del-cli 'dist/**/__tests__' && yarn tsc --emitDeclarationOnly\nAs you can see, it's quite long and hard to read. There's even a separate babel.config.publish.js file. And this only works for webpack and Metro, and will fail on Node due to ESM usage.react-native-builder-bob wraps tools such as babel and typescript to simplify these common tasks across multiple projects. While it can be used for any library, it's primarily tailored to React Native projects to minimize the configuration required.","how-do-i-add-a-react-native-library-containing-native-code-as-a-dependency-in-my-library#How do I add a react-native library containing native code as a dependency in my library?":"If your library depends on another react-native library containing native code, you should do the following:\nAdd the native library to peerDependenciesThis means that the consumer of the library will need to install the native library and add it to the dependencies section of their package.json. It makes sure that:\nThere are no version conflicts if another package also happens to use the same library, or if the user wants to use the library in their app. While there can be multiple versions of a JavaScript-only library, there can only be one version of a native library - so avoiding version conflicts is important.\nThe package manager installs it in correct location so that autolinking can work properly.\nDon't add the native library to dependencies of your library, otherwise it may cause issues for the user even if it seems to work.\nAdd the native library to devDependenciesThis makes sure that you can use it for tests, and there are no other errors such as type errors due to the missing module.\nAdd the native library to dependencies in the package.json under exampleThis is equivalent to the consumer of the library installing the dependency, and is needed so that this module is also available to the example app.","how-to-upgrade-the-react-native-version-in-the-generated-project#How to upgrade the react-native version in the generated project?":"Since this is a library, the react-native version specified in the package.json is not relevant for the consumers. It's only used for developing and testing the library. If you'd like to upgrade the react-native version to test with it, you'd need to:\nBump versions of the following packages under devDependencies in the package.json:\nreact-native\nreact\n@types/react\n@types/react-native\nIf you have any other related packages such as react-test-renderer, make sure to bump them as well.\nUpgrade react-native in the example appThe example app is a React Native app that can be updated following the same process as a regular React Native app. The process will vary depending on if it's using Expo or React Native CLI. See the official upgrade guide for more details.\nTo avoid issues, make sure that the versions of react and react-native are the same in example/package.json and the package.json at the root.","how-does-the-library-get-linked-to-the-example-app-in-the-generated-project#How does the library get linked to the example app in the generated project?":"If you generate a project with create-react-native-library, you get an example app to test your library. It's good to understand how the library gets linked to the example app in case you want to tweak how it works or if you run into issues.There are 2 parts to this process.\nAliasing the JavaScript codeThe JavaScript (or TypeScript) source code is aliased to be used by the example app. This makes it so that when you import from 'your-library-name', it imports the source code directly and avoids having to rebuild the library for JavaScript only changes. We configure several tools to make this work:\nMetro is configured to allow importing from outside of the example directory by configuring watchFolders, to use the appropriate peer dependencies, and to import source code of the library in the example. This configuration exists in the example/metro.config.js file.\nTypeScript is configured to use the source code for type checking by using the paths property under compilerOptions. This configuration exists in the tsconfig.json file at the root.\nLinking the native codeBy default, React Native CLI only links the modules installed under node_module of the app. To be able to link the android and ios folders from the project root, the path is specified in the example/react-native.config.js file.","how-to-test-the-library-in-an-app-locally#How to test the library in an app locally?":"You may have come across the yarn link and npm link commands, or used npm install ../path/to/folder or yarn add ../path/to/folder to test libraries locally. These commands may work for simple packages without build process, but they have different behavior from how a published package works, e.g. .npmignore is not respected, the structure of node_modules is different, etc. So we don't recommended using these approaches to test libraries locally.For more accurate testing, there are various other approaches:\nLocal tarball with npmFirst, temporarily change the version in package.json to something like 0.0.0-local.0. This version number needs to be updated to something different every time you do this to avoid stale content.Run the following command inside your library's root:\nnpm pack\nThis will generate a file like your-library-name-0.0.0-local.0.tgz in the root of the project.Then, you can install the tarball in your app:\nyarn add ../path/to/your-library-name-0.0.0-local.0.tgz\nOr if you use npm:\nnpm install ../path/to/your-library-name-0.0.0-local.0.tgz\nYalcYalc acts as a local repository for packages that can be used to test packages locally. It's similar to the previous workflow, but more convenient to use.You can find installation and usage instructions in the Yalc documentation.\nVerdaccioVerdaccio is a lightweight private npm registry that can be used to test packages locally. The advantage of using Verdaccio is that it allows to test the complete workflow of publishing and installing a package without actually publishing it to a remote registry.You can find installation and usage instructions in the Verdaccio documentation.","users-get-a-warning-when-they-install-my-library#Users get a warning when they install my library":"If users are using Yarn 1, they may get a warning when installing your library:\nwarning Workspaces can only be enabled in private projects.\nThis is because the example app is configured as a Yarn workspace, and there is a bug in Yarn 1 which causes this warning to be shown for third-party packages. It has no impact for the consumers of the library and the warning can be ignored. If consumers would like to get rid of the warning, there are 2 options:\nDisable workspacesIf the consumer doesn't use Yarn workspaces, they can disable it by adding the following to the .yarnrc file in the root of their project:\nworkspaces-experimental false\nUpgrade to Yarn 3Yarn 1 is no longer maintained, so it's recommended to upgrade to Yarn 3. Yarn 3 works with React Native projects with the node-modules linker. To upgrade, consumers can follow the official upgrade guide.It's also necessary to use node-modules linker. To use it, consumers can add the following to the .yarnrc.yml file in the root of their project:\nnodeLinker: node-modules"}},"/":{"title":"Introduction","data":{"":"This project is a collection of tools to make it easier to build React Native libraries. It contains the following CLIs:\ncreate-react-native-library - a CLI to scaffold a React Native library.\nreact-native-builder-bob - a CLI to build React Native libraries for various targets."}},"/build":{"title":"Build a React Native library","data":{"":"When code is in non-standard syntaxes such as JSX, TypeScript etc, it needs to be compiled before it can run. Configuring this manually can be error-prone and annoying. react-native-builder-bob aims to simplify this process by wrapping babel and tsc and taking care of the configuration. See this section for a longer explanation.Supported targets are:\nES modules build for modern tools\nCommonJS build for legacy tools\nTypeScript definitions\nFlow definitions (copies .js files to .flow files)\nCodegen generated scaffold code\nIf you created a project with create-react-native-library, react-native-builder-bob is already pre-configured to build your project. You don't need to configure it again.The following configuration steps are for projects not created with create-react-native-library.","automatic-configuration#Automatic configuration":"To automatically configure your project to use react-native-builder-bob, open a Terminal and run:\nnpx react-native-builder-bob@latest init\nThis will ask you a few questions and add the required configuration and scripts for building the code. The code will be compiled automatically when the package is published.You can find details on what exactly it adds in the Manual configuration section.","manual-configuration#Manual configuration":"To configure your project manually, follow these steps:\nFirst, install react-native-builder-bob in your project. Open a Terminal in your project, and run:\nyarn add --dev react-native-builder-bob\nIn your package.json, specify the targets to build for:\n\"react-native-builder-bob\": {\n  \"source\": \"src\",\n  \"output\": \"lib\",\n  \"targets\": [\n    [\"module\", { \"esm\": true }],\n    \"typescript\",\n  ]\n}\nSee the Options section for more details.\nAdd bob to your prepare or prepack step:\n\"scripts\": {\n  \"prepare\": \"bob build\"\n}\nNote that there is a difference between prepare and prepack scripts:\nprepare is run when:\nThe package is published with Yarn 1 (yarn publish), npm (npm publish) or pnpm (pnpm publish)\nThe package is installed from a GIT URL with Yarn 1 (yarn add <git-url>), npm (npm install <git-url>) or pnpm (pnpm add <git-url>)\nprepack is run when:\nThe package is published with any package manager (yarn publish, npm publish, pnpm publish)\nThe package is installed from a GIT URL with Yarn 4 (yarn add package-name@<git-url>)\nIf you are not sure which one to use, we recommend going with prepare as it works during both publishing and installing from GIT with more package managers.\nConfigure the appropriate entry points:\n\"main\": \"./lib/module/index.js\",\n\"types\": \"./lib/typescript/src/index.d.ts\",\n\"exports\": {\n  \".\": {\n     \"source\": \"./src/index.tsx\",\n     \"types\": \"./lib/typescript/src/index.d.ts\",\n     \"default\": \"./lib/module/index.js\"\n  },\n  \"./package.json\": \"./package.json\"\n},\n\"files\": [\n  \"lib\",\n  \"src\"\n]\nHere is what each of these fields mean:\nmain: The entry point for legacy setups that don't support the exports field. See Compatibility for more details.\ntypes: The entry point for the TypeScript definitions for legacy setups with moduleResolution: node10 or moduleResolution: node.\nexports: The entry points for tools that support the exports field in package.json - such as Node.js 12+, modern browsers and tools. See the ESM support guide for more details.\nfiles: The files to include in the package when publishing with npm.\nMake sure to change specify correct files according to the targets you have enabled.\nAdd the output directory to .gitignore and .eslintignore\n# generated files by bob\nlib/\nThis makes sure that you don't accidentally commit the generated files to git or get lint errors for them.\nAdd the output directory to jest.modulePathIgnorePatterns if you use Jest\n\"modulePathIgnorePatterns\": [\"<rootDir>/lib/\"]\nThis makes sure that Jest doesn't try to run the tests in the generated files.\nAnd we're done 🎉","options#Options":"The options can be specified in the package.json file under the react-native-builder-bob property, or in a bob.config.js file in your project directory.","source#source":"The name of the folder with the source code which should be compiled. The folder should include an index file.","output#output":"The name of the folder where the compiled files should be output to. It will contain separate folder for each target.","exclude#exclude":"Glob pattern to be used while filtering the unnecessary files. Defaults to '**/{__tests__,__fixtures__,__mocks__}/**' if not specified.Example:\n{\n  \"exclude\": \"ignore_me/**\"\n}\nThis option only works with commonjs and module targets. To exclude files while building typescript, please see the tsconfig exclude field.","targets#targets":"Various targets to build for. The available targets are:","module#module":"Enable compiling source files with Babel and use ES module system (import/export).This is useful for modern bundlers that understand ES modules. Bundlers such as webpack can also tree-shake code using ES modules.The output file should be referenced in the module field and exports['.'].import (when esm: true) field of package.json.By default, the code is compiled to support the last 2 versions of modern browsers. It also strips TypeScript and Flow annotations as well as compiles JSX code. You can customize the environments to compile for by using a browserslist config.In addition, the following options are supported:","esm#esm":"Setting this option to true will output ES modules compatible code for Node.js 12+, modern browsers and tools that support package.json's exports field.See the ESM support guide for more details.","configfile#configFile":"To customize the babel config used, you can pass the configFile option as true if you have a babel.config.js or a path to a custom config file. This will override the default configuration.It is recommended that you extend the default configuration by using the react-native-builder-bob/babel-preset preset in your custom config file:\nmodule.exports = {\n  presets: ['react-native-builder-bob/babel-preset'],\n};\nThis will make sure that the commonjs target produces code using CommonJS and the module target produces code using ES modules. It is also necessary for the esm option to work correctly.If you don't want to use the preset, then make sure to conditionally enable or disable the CommonJS transform with the following condition:\nmodule.exports = (api) => {\n  const isCommonJSTransformDisabled = api.caller(\n    // If `supportsStaticESM` is `true`, output ES modules, otherwise output CommonJS\n    (caller) => caller && caller.supportsStaticESM\n  );\n  return {\n    // Your config here\n  };\n};\nIf you're using @babel/preset-env with the modules option set to \"auto\" (which is the default), it will be automatically configured to correctly enable the CommonJS transform when needed, so additional configuration is not necessary.","babelrc#babelrc":"You can set the babelrc option to true to enable using .babelrc files. Similar considerations apply as with the configFile option.","jsxruntime#jsxRuntime":"By default, JSX is compiled to use the automatic runtime introduced in React 17. This transform is also compatible with React 16.14.0, React 15.7.0, and React 0.14.10.If you want to use the classic runtime for any other reason, you can set the jsxRuntime option to classic explicitly.This option has no effect when overriding the default babel configuration without using react-native-builder-bob/babel-preset.","copyflow#copyFlow":"If your source code is written in Flow, You can specify the copyFlow option to true to copy the source files as .js.flow to the output folder. If the main entry in package.json points to the index file in the output folder, the flow type checker will pick these files up to use for type definitions.","sourcemaps#sourceMaps":"Sourcemaps are generated by default alongside the compiled files. You can disable them by setting the sourceMaps option to false.Example:\n[\"module\", { \"esm\": true }]","commonjs#commonjs":"Enable compiling source files with Babel and use CommonJS module system. This is essentially the same as the module target and accepts the same options, but transforms the import/export statements in your code to require/module.exports.This is useful for supporting tools that don't support ES modules yet, see the Compatibility section in our ESM guide for more details.The output file should be referenced in the main field. If you have a dual package setup with both ESM and CommonJS builds, it needs to be specified in exports['.'].require field of package.json.Example:\n[\"commonjs\", { \"sourceMaps\": false, \"copyFlow\": true }]","typescript#typescript":"Enable generating type definitions with tsc if your source code is written in TypeScript.When both module and commonjs targets are enabled, and esm is set to true for the module target, this will output 2 sets of type definitions: one for the CommonJS build and one for the ES module build.The following options are supported:","project#project":"By default, the tsconfig.json file in the root of your project is used to generate the type definitions. You can specify a path to a different config by using the project option. This can be useful if you need to use different configs for development and production.","tsc#tsc":"The path to the tsc binary is automatically detected and defaults to the one installed in your project. You can use the tsc option to specify a different path.Example:\n[\"typescript\", { \"project\": \"tsconfig.build.json\" }]\nThe output file should be referenced in the exports['.'].types field of package.json.If you need to support legacy setups that use moduleResolution: node10 or moduleResolution: node, you can also add a types field to the package.json file that points to the output file.","codegen#codegen":"Enable generating the React Native Codegen scaffold code when building the library.If you use this target, you'll also want to use \"includesGeneratedCode\": true to ship the generated code with your library. Before you do so, make sure to read the official docs to understand the advantages and tradeoffs of this approach.If you want to ship codegen generated code with your library, you can do the following steps to integrate it with the library's workflow:\nAdd the codegen target to the react-native-builder-bob field in your package.json or bob.config.js:\n \"source\": \"src\",\n \"output\": \"lib\",\n \"targets\": [\n   // …\n+  \"codegen\"\n ]\nThis will enable the codegen script to run when you publish the library (if bob build is configured to be run on publish).\nAdd @react-native-community/cli as a devDependency in your package.json:\n\"devDependencies\": {\n  // …\n+ \"@react-native-community/cli\": \"^x.x.x\"\n}\nFor the @react-native-community/cli version, refer to the example/package.json file. The version should be the same as the one used in the example app.\nAdd \"includesGeneratedCode\": true and \"outputDir\" to the codegenConfig field in your package.json:\n\"codegenConfig\": {\n  // …\n+ \"outputDir\": {\n+   \"ios\": \"ios/generated\",\n+   \"android\": \"android/generated\"\n+ },\n+ \"includesGeneratedCode\": true\n}\nUpdate imports in your ios code to use the new paths for the generated code:\nIf you have a Turbo Module, replace YourProjectNameSpec.h with YourProjectName/YourProjectNameSpec.h:\n- #import <YourProjectNameSpec/YourProjectNameSpec.h>\n+ #import <YourProjectName/YourProjectNameSpec.h>\nIf you have a Fabric View, replace react/renderer/components/YourProjectNameViewSpec/ with YourProjectName/:\n- #import <react/renderer/components/YourProjectNameViewSpec/ComponentDescriptors.h>\n- #import <react/renderer/components/YourProjectNameViewSpec/EventEmitters.h>\n- #import <react/renderer/components/YourProjectNameViewSpec/Props.h>\n- #import <react/renderer/components/YourProjectNameViewSpec/RCTComponentViewHelpe\nrs.h>\n+ #import <YourProjectName/ComponentDescriptors.h>\n+ #import <YourProjectName/EventEmitters.h>\n+ #import <YourProjectName/Props.h>\n+ #import <YourProjectName/RCTComponentViewHelpers.h>\nAdd a react-native.config.js at the root with the correct cmakeListsPath:\n/**\n * @type {import('@react-native-community/cli-types').UserDependencyConfig}\n */\nmodule.exports = {\n  dependency: {\n    platforms: {\n      android: {\n        cmakeListsPath: 'generated/jni/CMakeLists.txt',\n      },\n    },\n  },\n};\nThis makes sure that gradle will pickup the CMakeLists.txt file generated by the codegen script on Android.\nAdd a gradle task to example/android/app/build.gradle to automatically run the codegen script when building the example app:\ntasks.register('invokeLibraryCodegen', Exec) {\n  workingDir \"$rootDir/../../\"\n  def isWindows = System.getProperty('os.name').toLowerCase().contains('windows')\n  if (isWindows) {\n    commandLine 'cmd', '/c', 'npx bob build --target codegen'\n  } else {\n    commandLine 'sh', '-c', 'npx bob build --target codegen'\n  }\n}\npreBuild.dependsOn invokeLibraryCodegen\nAdd a pre_install hook to example/ios/Podfile to automatically run the codegen script when installing pods:\npre_install do |installer|\n  system(\"cd ../../ && npx bob build --target codegen\")\nend\nThis will likely be inside the target 'YourAppName' do block.\nAnd you're done! Make sure to run pod install in the example/ios folder and then run the example app to make sure everything works.","custom#custom":"Define a custom build target. This is useful to call custom scripts during when running bob build.","script#script":"Name of the script to run. The script must be defined in the package.json file under the scripts property. This property is required.This script is run asynchronously alongside the other build targets.","clean#clean":"Optionally, you can specify a path to cleanup before running the build script. The path is resolved relatively to where build was called from.This is useful if your script generates output files. Cleaning the output folder before running the script ensures that the output doesn't contain stale files.Example:\n[\"custom\", { \"script\": \"my-custom-build\", \"clean\": \"my-output-folder/\" }]","commands#Commands":"The bob CLI exposes the following commands:","init#init":"This configures an existing project to use bob by adding the required configuration and dependencies. This is usually run with npx:\nnpx react-native-builder-bob@latest init","build#build":"This builds the project according to the configuration. This is usually run as part of the package's publishing flow, i.e. in the prepare or prepack scripts.\n\"scripts\": {\n  \"prepare\": \"bob build\"\n}"}},"/esm":{"title":"ESM support","data":{"default-setup#Default setup":"Libraries created with create-react-native-library are pre-configured to work with ESM (ECMAScript Modules) out of the box.You can verify whether ESM support is enabled by checking the configuration for react-native-builder-bob in the package.json file of the library:\n\"react-native-builder-bob\": {\n  \"source\": \"src\",\n  \"output\": \"lib\",\n  \"targets\": [\n    [\"module\", { \"esm\": true }],\n    \"typescript\"\n  ]\n}\nThe \"esm\": true option enables ESM-compatible output by adding the .js extension to the import statements in the generated files. This is necessary if you want to be able to import the library on Node.js or in a bundler that supports ESM, with some caveats. See the Guidelines section for more information.For TypeScript, it also generates 2 sets of type definitions if the commonjs target is also enabled: one for the CommonJS build and one for the ES module build.It's recommended to specify \"moduleResolution\": \"bundler\" in your tsconfig.json file to match Metro's behavior:\n{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"bundler\"\n  }\n}\nSpecifying \"moduleResolution\": \"bundler\" means that you don't need to use file extensions in the import statements. Bob automatically adds them when possible during the build process.To make use of the output files, ensure that your package.json file contains the following fields:\n\"main\": \"./lib/module/index.js\",\n\"types\": \"./lib/typescript/src/index.d.ts\",\n\"exports\": {\n  \".\": {\n    \"source\": \"./src/index.tsx\",\n    \"types\": \"./lib/typescript/src/index.d.ts\",\n    \"default\": \"./lib/module/index.js\"\n  },\n  \"./package.json\": \"./package.json\"\n},\nThe main field is for tools that don't support the exports field (e.g. Metro < 0.82.0). The types field is for legacy TypeScript setups that use moduleResolution: \"node10\" or moduleResolution: \"node\".The exports field is used by Node.js 12+, modern browsers and tools to determine the correct entry point. The entrypoint is specified in the . key and will be used when the library is imported or required directly (e.g. import 'my-library' or require('my-library')).Here, we specify 3 conditions:\nsource: A custom condition used by react-native-builder-bob to determine the source file for the library.\ntypes: Used for the TypeScript definitions.\ndefault: Used for the actual JS code when the library is imported or required.\nYou can also specify additional conditions for different scenarios, such as react-native, browser, production, development etc. Note that support for these conditions depends on the tooling you're using.The ./package.json field is used to point to the library's package.json file. It's necessary for tools that may need to read the package.json file directly (e.g. React Native Codegen).Using the exports field has a few benefits, such as:\nIt restricts access to the library's internals by default. You can explicitly specify which files are accessible with subpath exports.\nIt allows you to specify different entry points for different environments with conditional exports (e.g. node, browser, module, react-native, production, development etc.).","a-note-on-importmeta#A note on import.meta":"The import.meta object is available in ESM. As per the spec, different tools may add different properties to it.For example, Node.js adds import.meta.resolve and more, Webpack adds import.meta.webpackHot, import.meta.webpackContext and more, Vite adds import.meta.env and more, etc. Most tools support the import.meta.url property, which is a URL string representing the module's location.Additionally, the import.meta syntax is currently not supported in Metro (React Native) and will result in a syntax error.So be careful when using properties from import.meta, as relying on properties only available in specific tools may lock your library into supporting only those specific tools. Also, since this is an ESM-only feature, you should avoid using it if you compile your library to CommonJS as well.","dual-package-setup#Dual package setup":"The previously mentioned setup only works with tools that support ES modules. If you want to support tools that don't support ESM and use the CommonJS module system, you can configure a dual package setup.A dual package setup means that you have 2 builds of your library: one for ESM and one for CommonJS. The ESM build is used by tools that support ES modules, while the CommonJS build is used by tools that don't support ES modules.To configure a dual package setup, you can follow these steps:\nAdd the commonjs target to the react-native-builder-bob field in your package.json or bob.config.js:\n\"react-native-builder-bob\": {\n  \"source\": \"src\",\n  \"output\": \"lib\",\n  \"targets\": [\n    [\"module\", { \"esm\": true }],\n+   [\"commonjs\", { \"esm\": true }]\n    \"typescript\",\n  ]\n}\nChange the exports field in your package.json to include 2 conditions:\n\"exports\": {\n  \".\": {\n-   \"types\": \"./lib/typescript/src/index.d.ts\",\n-   \"default\": \"./lib/module/index.js\"\n+   \"import\": {\n+     \"types\": \"./lib/typescript/module/src/index.d.ts\",\n+     \"default\": \"./lib/module/index.js\"\n+   },\n+   \"require\": {\n+     \"types\": \"./lib/typescript/commonjs/src/index.d.ts\",\n+     \"default\": \"./lib/commonjs/index.js\"\n+   }\n  }\n},\nHere, we specify 2 conditions:\nimport: Used when the library is imported with an import statement or a dynamic import(). It will point to the ESM build.\nrequire: Used when the library is required with a require call. It will point to the CommonJS build.\nEach condition has a types field - necessary for TypeScript to provide the appropriate definitions for the module system. The type definitions have slightly different semantics for CommonJS and ESM, so it's important to specify them separately.The default field is the fallback entry point for both conditions. It's used for the actual JS code when the library is imported or required.\nOptionally change the main field in your package.json to point to the CommonJS build:\n- \"main\": \"./lib/module/index.js\",\n+ \"main\": \"./lib/commonjs/index.js\",\nThis is needed if you want to support tools that don't support the exports field and need to use the CommonJS build.\nOptionally add a module field in your package.json to point to the ESM build:\n  \"main\": \"./lib/commonjs/index.js\",\n+ \"module\": \"./lib/module/index.js\",\nThe module field is a non-standard field that some tools use to determine the ESM entry point.\nOptionally change the types field in your package.json to point to the CommonJS type definitions:\n  \"main\": \"./lib/commonjs/index.js\",\n  \"module\": \"./lib/module/index.js\",\n- \"types\": \"./lib/typescript/src/index.d.ts\",\n+ \"types\": \"./lib/typescript/commonjs/src/index.d.ts\",\nThis is necessary to support legacy TypeScript setup, i.e. which have moduleResolution: \"node10\" or moduleResolution: \"node\" under the compilerOptions section in the tsconfig.json.\nPutting it all together, the fields in your package.json file should look like this:\n{\n  \"main\": \"./lib/commonjs/index.js\",\n  \"module\": \"./lib/module/index.js\",\n  \"types\": \"./lib/typescript/commonjs/src/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"import\": {\n        \"types\": \"./lib/typescript/module/src/index.d.ts\",\n        \"default\": \"./lib/module/index.js\"\n      },\n      \"require\": {\n        \"types\": \"./lib/typescript/commonjs/src/index.d.ts\",\n        \"default\": \"./lib/commonjs/index.js\"\n      }\n    },\n    \"./package.json\": \"./package.json\"\n  }\n}","dual-package-hazard#Dual package hazard":"With this approach, the ESM and CommonJS versions of the package are treated as separate modules by Node.js as they are different files. On Node.js, import will load the ESM package and require will load the CommonJS package, leading to potential issues if the package is both imported and required in the same runtime environment.If the library relies on any state that can cause issues if 2 separate instances are loaded (e.g. global state, constructors, react context etc.), it's necessary to isolate the state into a separate CommonJS module that can be shared between the ESM and CommonJS builds.","alternative-approach#Alternative approach":"An alternative approach to classic dual package setup is to use tool specific conditions instead of specifying both import and require. This way, each tool can load the appropriate build without resulting in a dual package hazard.For example, here is a setup that uses ESM for Webpack, Vite, Rollup, Metro (React Native) and Node.js, and CommonJS for the rest:\n{\n  \"main\": \"./lib/commonjs/index.js\",\n  \"module\": \"./lib/module/index.js\",\n  \"types\": \"./lib/typescript/commonjs/src/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"react-native\": {\n        \"types\": \"./lib/typescript/module/src/index.d.ts\",\n        \"default\": \"./lib/module/index.js\"\n      },\n      \"node\": {\n        \"types\": \"./lib/typescript/module/src/index.d.ts\",\n        \"default\": \"./lib/module/index.js\"\n      },\n      \"module\": {\n        \"types\": \"./lib/typescript/module/src/index.d.ts\",\n        \"default\": \"./lib/module/index.js\"\n      },\n      \"default\": {\n        \"types\": \"./lib/typescript/commonjs/src/index.d.ts\",\n        \"default\": \"./lib/commonjs/index.js\"\n      }\n    },\n    \"./package.json\": \"./package.json\"\n  }\n}\nHere, we specify 4 conditions:\nreact-native: Used when the library is imported in a React Native environment with Metro.\nnode: Used when the library is imported in Node.js.\nmodule: Used when the library is imported in a bundler such as Webpack, Vite or Rollup.\ndefault: Fallback used when the library is imported in an environment that doesn't support the other conditions.\nOne thing to note is that TypeScript may need to be configured to resolve to the appropriate condition. It's pre-configured for React Native apps, but in other scenarios, it maybe necessary to specify customConditions in the tsconfig.json file:\n{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"bundler\",\n    \"customConditions\": [\"module\"]\n  }\n}\nThis is just an example to illustrate the idea. In practice, you may want to specify appropriate conditions for your library based on the tools you want to support.You can find a list of conditions supported in various tools in the Runtime Keys proposal specification, Node.js documentation and Webpack documentation.","compatibility#Compatibility":"Node.js v12 and higher natively support ESM and the exports field. However, in a CommonJS environment, an ESM library can be loaded synchronously only in recent Node.js versions. The following Node.js versions support synchronous require() for ESM libraries without any flags or warnings:\nv20.19.0 and higher (LTS)\nv22.12.0 and higher (LTS)\nv23.4.0 and higher\nOlder versions can still load your library asynchronously using import() in CommonJS environments.Most modern tools such as Webpack, Rollup, Vite etc. also support ESM and the exports field. See the supported conditions in the Runtime Keys proposal specification, Node.js documentation and Webpack documentation.Metro enables support for package.json exports by default from version 0.82.0. In previous versions, experimental support can be enabled by setting the unstable_enablePackageExports option to true in the Metro configuration. If this is not enabled, Metro will use the entrypoint specified in the main field. Features such as subpath exports and conditional exports will not work when exports supported is not enabled.Jest supports the exports field, but doesn't support ESM natively. Experimental support is available under a flag, but requires changes to how tests are written. It can still load ESM libraries using a transform such as babel-jest.","guidelines#Guidelines":"There are still a few things to keep in mind if you want your library to be ESM-compatible:\nAvoid using default exports in your library. Named exports are recommended. Default exports produce a CommonJS module with a default property, which will work differently than the ESM build and can cause issues if you have a dual package setup. Needing to use .default in CommonJS environment may also be confusing for users.\nIf the library uses platform-specific extensions (e.g., .ios.js or .android.js), the ESM output will not be compatible with Node.js, i.e. it's not possible to use the library in Node.js with import syntax. It's necessary to omit file extensions from the imports to make platform-specific extensions work, however, Node.js requires file extensions to be present.While Bob automatically adds file extensions to the import statements during the build process if esm is set to true, it will skip the imports that reference files with platform-specific extensions to avoid breaking the resolution.Bundlers such as Metro can handle imports without file extensions for ESM without additional configuration. Other bundlers may need to be configured to make extensionless imports to work, (e.g. it's necessary to specify resolve.fullySpecified: false for Webpack).It's still possible to use the library in Node.js using the CommonJS build with require:\nconst { foo } = require('my-library');\nAlternatively, if you want to be able to use the library in Node.js with import syntax, there are a few options:\nUse Platform.select instead of platform-specific extensions:\nimport { Platform } from 'react-native';\nconst foo = Platform.select({\n  android: require('./fooAndroid.js'),\n  ios: require('./fooIOS.js'),\n  default: require('./fooFallback.js'),\n});\nUse require to import code with platform-specific extensions in your library:\n// will import `foo.native.js`, `foo.ios.js`, `foo.js` etc.\nconst { foo } = require('./foo');\nMake sure to have a file without any platform-specific extensions that will be loaded by Node.js.Also note that if your module (e.g. foo.js in this case) contains ESM syntax, it will only work on a recent Node.js version. See Compatibility section for more information.\nAvoid using .cjs, .mjs, .cts or .mts extensions. Metro always requires file extensions in import statements when using .cjs or .mjs which breaks platform-specific extension resolution.\nAvoid using \"moduleResolution\": \"node16\" or \"moduleResolution\": \"nodenext\" in your tsconfig.json file. They require file extensions in import statements which breaks platform-specific extension resolution.\nIf you specify a react-native condition in exports, make sure that it comes before other conditions. The conditions should be ordered from the most specific to the least specific:\n\"exports\": {\n  \".\": {\n    \"types\": \"./lib/typescript/src/index.d.ts\",\n    \"react-native\": \"./lib/modules/index.native.js\",\n    \"default\": \"./lib/module/index.js\"\n  }\n}\nOr for a dual package setup:\n\"exports\": {\n  \".\": {\n    \"import\": {\n      \"types\": \"./lib/typescript/module/src/index.d.ts\",\n      \"react-native\": \"./lib/module/index.native.js\",\n      \"default\": \"./lib/module/index.js\"\n    },\n    \"require\": {\n      \"types\": \"./lib/typescript/commonjs/src/index.d.ts\",\n      \"react-native\": \"./lib/commonjs/index.native.js\",\n      \"default\": \"./lib/commonjs/index.js\"\n    }\n  },\n  \"./package.json\": \"./package.json\"\n}\nOr as a separate condition:\n\"exports\": {\n  \".\": {\n    \"react-native\": {\n      \"types\": \"./lib/typescript/module/src/index.native.d.ts\",\n      \"default\": \"./lib/module/index.native.js\"\n    },\n    \"import\": {\n      \"types\": \"./lib/typescript/module/src/index.d.ts\",\n      \"default\": \"./lib/module/index.js\"\n    },\n    \"require\": {\n      \"types\": \"./lib/typescript/commonjs/src/index.d.ts\",\n      \"default\": \"./lib/commonjs/index.js\"\n    }\n  },\n}","references#References":"Node.js documentation on ESM\nPublishing dual module ESM libraries\nAre the types wrong?\ntshy - TypeScript HYbridizer"}}}